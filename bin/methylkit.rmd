---
params:
  study: "Study Name"
  metadata_path: "path/to/metadata.csv"
  bismark_path: "path/to/bismark"
  chromhmm_path: "path/to/chromhmm_segments.bed"
  ccre_path: "path/to/cCREs.bed"
  blacklist_path: "path/to/blacklist.bed"
  out_path: "path/to/methylkit"
  assembly: "genome_assembly"
title: |
  | Differential methylation analysis report
  | `r params$study`
date: "`r Sys.Date()`"
author: "`r Sys.info()[['user']]`"
version: "1.0"
output:
  rmdformats::readthedown:
    toc_depth: 6
    self_contained: yes
    
css: methylkit.css
---
<!--
# Differential Methylation Analysis Report
This R Markdown document performs differential methylation analysis for a specified study. 
It includes QC analysis, statistical analysis, and visualization of results.


Usage from R console:
rmarkdown::render(
  "bin/methylkit.rmd", 
  params = list(
    study = "JIRA_BDS-XXXX_12ABIC_EPI321_vs_CONTROL", 
    metadata_path = "/home/tylerborrman/epic-methylseq_data/test_12ABIC/samplesheet_test_12ABIC.csv",
    bismark_path = "/home/tylerborrman/epic-methylseq_data/test_12ABIC",
    chromhmm_path = "/home/tylerborrman/epic-methylseq_data/ChromHMM/hg38_genome_100_segments.bed",
    ccre_path = "/home/tylerborrman/epic-methylseq_data/cCRE/GRCh38-cCREs.bed",
    blacklist_path = "/home/tylerborrman/epic-methylseq_data/blacklist/hg38-blacklist.v2.bed",
    out_path = "/home/tylerborrman/epic-methylseq_data/test_12ABIC/methylkit",
    assembly = "hg38"
  )
)

Usage from command line:
Rscript -e "rmarkdown::render(
  'bin/methylkit.rmd',
  params = list(
    study = 'JIRA_BDS-XXXX_12ABIC_EPI321_vs_CONTROL',
    metadata_path = '/home/tylerborrman/epic-methylseq_data/test_12ABIC/samplesheet_test_12ABIC.csv',
    bismark_path = '/home/tylerborrman/epic-methylseq_data/test_12ABIC',
    chromhmm_path = "/home/tylerborrman/epic-methylseq_data/ChromHMM/hg38_genome_100_segments.bed",
    ccre_path = "/home/tylerborrman/epic-methylseq_data/cCRE/GRCh38-cCREs.bed",
    blacklist_path = "/home/tylerborrman/epic-methylseq_data/blacklist/hg38-blacklist.v2.bed",
    out_path = '/home/tylerborrman/epic-methylseq_data/test_12ABIC/methylkit',
    assembly = 'hg38'
  )
)"

params:
  study: Study Name with JIRA ID prefix
  metadata_path: path to samplesheet used in nfcore/methylseq pipeline with additional condition column
  bismark_path: path to directory containing bismark coverage files (.deduplicated.bismark.cov)
  chromhmm_path = path to ChromHMM annotation file
  ccre_path = path to ENCDOE cCRE annotation file
  blacklist_path = path to ENCODE blacklist annotation file
  out_path: path to directory to save methylkit output files
  assembly: genome assembly used in the analysis (e.g. hg38, mm10)
-->

```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE,cache=FALSE)
# load packages
library(DT)
library(methylKit)
library(plotly)
library(ggplot2)
library(dplyr)
library(tidyr)
library(readr)
library(GenomicRanges)
library(rtracklayer)
```

# Dataset overview

```{r dataset overview}
# Load metadata
metadata <- read_csv(params$metadata_path)
metadata <- metadata[c("sample", "condition")]
datatable(metadata)
metadata <- as.data.frame(metadata)
rownames(metadata) <- metadata$sample
```

# Descriptive statistics

```{r descriptive statistics}

# Function to find files with a given prefix
find_files_with_prefix <- function(prefix, files) {
  matching_files <- grep(prefix, files, value = TRUE)
  if (length(matching_files) == 1) {
    return(matching_files)
  } else {
    stop(paste0("ERROR: No file or multiple files found for sample with prefix ", prefix))
  }
}
unordered_files <- list.files(
  params$bismark_path,
  pattern = ".cov",
  full.names = TRUE
)
# Ensure files are ordered according to metadata sample sheet
cov_files <- as.list(sapply(metadata$sample, find_files_with_prefix, files = unordered_files))

# Currently only supporting EPI321 vs Control comparison
treatment <- ifelse(metadata$condition == "EPI321", 1, 0)
treated <- metadata$sample[metadata$condition == "EPI321"]
control <- metadata$sample[metadata$condition == "CONTROL"]

# read methylation call files and store them as flat file database
# Note gzipped files are supported
# Note that the doc for methylKit says bismark coverage files have 5 cols, 
# but the bismark coverage files have 6 cols and the code for the methylKit methRead function expects 6 cols:
# chr, start, end, % meth, count methylated, count unmethylated

myobj=methRead(cov_files,
                sample.id=as.list(metadata$sample),
                pipeline="bismarkCoverage",
                assembly=params$assembly,
                treatment=treatment,
                context="CpG",
                dbtype = "tabix",
                dbdir = "methylDB",
                header = FALSE
)

# Descriptive statistics on samples
getMethylationStats(myobj[[1]],plot=TRUE,both.strands=FALSE) # check methylation stats on first sample
getCoverageStats(myobj[[1]],plot=TRUE,both.strands=FALSE) # check coverage stats on first  sample 
```

# Comparative Analysis
## CpG analysis
```{r comparative analysis}
# Comparative analysis
#  Merging all samples into one file. This is needed as precursor for dmc analyses  
meth=methylKit::unite(myobj, destrand=FALSE)
clusterSamples(meth, dist="correlation", method="ward.D2", plot=TRUE)
PCASamples(meth, screeplot=TRUE)
PCASamples(meth, adj.lim=c(0.5,0.5))

```


## Tiling windows analysis
For some situations, it might be desirable to summarize methylation information over tiling windows rather than doing base-pair resolution analysis.
For example, here we tile the genome with windows of 100bp and step-size 100bp and summarize the methylation information on those tiles.
This returns a methylRawList object which can be fed into unite and calculateDiffMeth functions consecutively to get differentially methylated regions.
The tilling function adds up C and T counts from each covered cytosine and returns a total C and T count for each tile.

```{r tiling_window_analysis}

# converting my.obj to tile object for sliding 100 bp windows minimum coverage of 5 CpGs 
tile.obj=tileMethylCounts(myobj,win.size=100,step.size=100,cov.bases=5)

# in this version of the code we only required 2 out of the 3 total merged samples (one sample per patient source) to contain a methylation site for it to be included in the comparative analyses if min.per.group is not specified default is all samples must have a specific CpG site or meth tile covered to include it. 
# meth.tile=methylKit::unite(tile.obj, destrand=FALSE, min.per.group = 2L) 

# In this version of the code we are requiring all samples to have a methylation site for it to be included in the comparative analyses.
meth.tile=methylKit::unite(tile.obj, destrand=FALSE)

PCASamples(meth.tile)
# find DMRs 
myDiff.tile=calculateDiffMeth(meth.tile)
```

# DMR no cut-off Tiling hyper/hypo methylated regions per chromosome
** In this section we will visualize the distribution of hypo/hyper-methylated bases/regions per chromosome.

```{r hyper/hypo_methylation, eval=FALSE}
# diffMethPerChr(myDiff.tile,plot=TRUE,qvalue.cutoff=1, meth.cutoff=25)
diffMethPerChr(myDiff.tile,plot=TRUE,qvalue.cutoff=1, meth.cutoff=21)


```

# Differentially methylated bases or regions
The calculateDiffMeth() function is the main function to calculate differential methylation.
Depending on the sample size per each set it will either use Fisher’s exact or logistic regression to calculate P-values.
P-values will be adjusted to Q-values using SLIM method (Wang, Tuominen, and Tsai 2011).
Note: if we have replicates, the function will automatically use logistic regression.
You can force the calculateDiffMeth() function to use Fisher’s exact test if you pool the replicates when there is only test and control sample groups.

```{r diff_meth_cpg}

## Finding differentially methylated CpGs (differentially methylated regions is in the previous section)
myDiff=calculateDiffMeth(meth)
```


```{r making_bed_files}

# Extracting data from the methylDiff objects and writing to bed files

## for tiling
select.meth <- getData(myDiff.tile) #DMRs

## for CpG sites 
select.meth2 <- getData(myDiff) #DMCs

# write bedfile
meth.bed <- as.data.frame(select.meth) #dmr
meth.bed2 <- as.data.frame(select.meth2)#dmc
write.table(meth.bed, paste0(params$out_path, "/", params$study,".meth.tile.all.bed"), sep="\t", col.names=FALSE, row.names=FALSE, quote=FALSE)
write.table(meth.bed2, paste0(params$out_path, "/", params$study,".meth.cpg.all.bed"), sep="\t", col.names=FALSE, row.names=FALSE, quote=FALSE)
```


```{r percent_methylation_tile}

perc.meth.tile=percMethylation(meth.tile, rowids = TRUE)
perc.meth.tile <- as.data.frame(perc.meth.tile)
perc.meth.tile$avg_treat <- rowMeans(perc.meth.tile[, colnames(perc.meth.tile) %in% treated], na.rm = TRUE)
perc.meth.tile$avg_ctrl <- rowMeans(perc.meth.tile[, colnames(perc.meth.tile) %in% control], na.rm = TRUE)
perc.meth.tile$coord <- rownames(perc.meth.tile)
meth.bed$coord <- paste0(meth.bed$chr,".",meth.bed$start,".",meth.bed$end)
perc.meth.tile <- merge(perc.meth.tile, meth.bed, by="coord")

# This is the final MR file we want!!!! 
write.table(
  perc.meth.tile,
  file = paste0(params$out_path, "/", params$study,".perc.meth.tile.all.tsv"),
  sep="\t",
  col.names=TRUE,
  row.names=FALSE,
  quote=FALSE
)
# This is the final DMR file we want!!!!
perc.meth.tile.sig <- perc.meth.tile[perc.meth.tile$qvalue < 0.01 & abs(perc.meth.tile$meth.diff) > 10,]
total_sig_dmrs <- nrow(perc.meth.tile.sig)

write.table(
  perc.meth.tile.sig,
  file = paste0(params$out_path, "/", params$study,".perc.meth.tile.all.q0.01.methdiff.10.tsv"),
  sep="\t",
  col.names=TRUE,
  row.names=FALSE,
  quote=FALSE
)
```

```{r volcano_plot, fig.height=10, fig.width=10}

# Label significance groups
perc.meth.tile$sig.group <- "NS"
perc.meth.tile$sig.group[perc.meth.tile$qvalue < 0.01 & abs(perc.meth.tile$meth.diff) <= 10] <- "qvalue"
perc.meth.tile$sig.group[perc.meth.tile$qvalue >= 0.01 & abs(perc.meth.tile$meth.diff) > 10] <- "meth.diff"
perc.meth.tile$sig.group[perc.meth.tile$qvalue < 0.01 & abs(perc.meth.tile$meth.diff) > 10] <- "qvalue and meth.diff"


# Borrowing EnhancedVolcano theme
th <- theme_bw(base_size = 24) +
  theme(
    legend.background = element_rect(),

    # title, subtitle, and caption
    plot.title = element_text(
      angle = 0,
      size = 18,
      face = 'bold',
      vjust = 1),
    plot.subtitle = element_text(
        angle = 0,
        size = 14,
        face = 'plain',
        vjust = 1),
    plot.caption = element_text(
      angle = 0,
      size = 14,
      face = 'plain',
      vjust = 1),

    # axis text
    axis.text.x = element_text(
      angle = 0,
      size = 18,
      vjust = 1),
    axis.text.y = element_text(
      angle = 0,
      size = 18,
      vjust = 0.5),
    axis.title = element_text(
      size = 18),
    axis.line = element_line(
      size = 0.8,
      colour = 'black'),
    panel.border = element_blank(),
    panel.background = element_blank(),

    # legend
    legend.position = 'top',
    legend.key = element_blank(),
    legend.key.size = unit(0.5, 'cm'),
    legend.text = element_text(
      size = 14),
    title = element_text(
      size = 14),
    legend.title = element_blank()
  )

# Plot Volcano
ggplot(
  data = perc.meth.tile,
  aes(
    x = meth.diff,
    y = -log10(qvalue)
  ) 
  ) +
  geom_point(
    aes(
      color = sig.group,
      alpha = 0.6
    ),
    show.legend = c(
      size = FALSE,
      alpha = FALSE
    ),
    size = 2
  ) +
  geom_vline(
    xintercept = c(-10, 10),
    col = "black",
    linewidth = 0.4,
    linetype = "longdash"
  ) +
  geom_hline(
    yintercept = -log10(0.01),
    col = "black",
    linewidth = 0.4,
    linetype = "longdash"
  ) +
  #ylim(0, 50) + 
  scale_color_manual(
    values=c(
      "NS" = "grey30",
      "qvalue" = "royalblue",
      "meth.diff" = "forestgreen",
      "qvalue and meth.diff" = "red2"
    ),
    breaks=c(
      "NS",
      "qvalue",
      "meth.diff",
      "qvalue and meth.diff"
    )
  ) +
  th +
  labs(
    x = "% methylation change",
    y = "-log10(qvalue)",
    title = "EPI321 vs CONTROL total DMRs",
    subtitle = "Thresholds: qvalue=0.01, meth.diff=10"
  ) +
  guides(
    color = guide_legend(
      override.aes = list(
        size = 5.0
      )
    )
  )
```


```{r percent_methylation_cpg}

perc.meth.cpg=percMethylation(meth, rowids = TRUE)
perc.meth.cpg <- as.data.frame(perc.meth.cpg)
perc.meth.cpg$avg_treat <- rowMeans(perc.meth.cpg[,colnames(perc.meth.cpg) %in% treated], na.rm = TRUE)
perc.meth.cpg$avg_ctrl <- rowMeans(perc.meth.cpg[, colnames(perc.meth.cpg) %in% control], na.rm = TRUE)
perc.meth.cpg$coord <- rownames(perc.meth.cpg)
meth.bed2$coord <- paste0(meth.bed2$chr,".",meth.bed2$start,".",meth.bed2$end)
perc.meth.cpg <- merge(perc.meth.cpg, meth.bed2, by="coord")

# This is the final CpG file we want!!!! 
write.table(
  perc.meth.cpg,
  file = paste0(params$out_path, "/", params$study,".perc.meth.cpg.all.tsv"),
  sep="\t",
  col.names=TRUE,
  row.names=FALSE,
  quote=FALSE
)

# This is the final DMC file we want!!!
perc.meth.cpg.sig <- perc.meth.cpg[perc.meth.cpg$qvalue <=0.01 & abs(perc.meth.cpg$meth.diff) > 10,]
write.table(
  perc.meth.cpg.sig,
  file = paste0(params$out_path, "/", params$study,".perc.meth.cpg.all.q0.01.methdiff.10.tsv"),
  sep="\t",
  col.names=TRUE,
  row.names=FALSE,
  quote=FALSE
)
```


# DMR annotation
```{r dmr_annotation}
# Generate Granges object from DMRs dataframe
dmrs_df <- perc.meth.tile.sig[c("chr", "start", "end", "qvalue", "meth.diff")]
dmrs_gr <- makeGRangesFromDataFrame(
  dmrs_df,
  ignore.strand = TRUE,
  keep.extra.columns = TRUE,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end"
)
```

## ChromHMM

```{r chromhmm}

# Load ChromHMM annotation
chromhmm_gr <- rtracklayer::import(params$chromhmm_path)
chromhmm_df <- as.data.frame(chromhmm_gr)
chromhmm_df <- chromhmm_df["name"]

# Calculate overlaps between DMRs and ChromHMM annotations
hits_obj <- findOverlaps(dmrs_gr, chromhmm_gr)

dmrs_overlap <- dmrs_df[queryHits(hits_obj),]
chromhmm_overlap <- chromhmm_df[subjectHits(hits_obj),]
ChromHMM.state <- chromhmm_overlap
overlap_df <- cbind(dmrs_overlap, ChromHMM.state)

count_dmr_overlap <- length(unique(queryHits(hits_obj)))
```

```{asis, echo = basename(params$chromhmm_path) == "hg38_genome_100_segments.bed"}
ChromHMM annotations were sourced from https://github.com/ernstlab/full_stack_ChromHMM_annotations
```

```{asis, echo = basename(params$chromhmm_path) == "mm10_100_segments_segments.bed"}
ChromHMM annotations were sourced from https://github.com/ernstlab/mouse_fullStack_annotations
```

**`r count_dmr_overlap` / `r total_sig_dmrs`** 
**(`r round((count_dmr_overlap / total_sig_dmrs) * 100, 2)` %)** of DMRs overlap with ChromHMM annotations.  
Note: a single DMR may have multiple ChromHMM annotations.

```{r chromhmm_table}
# Display in table
round_cols <- c("qvalue", "meth.diff")
bp_cols <- c("start", "end")

datatable(
  overlap_df,
  rownames = FALSE,
  extensions = "Buttons",
  options = list(
    dom = "Bfrtip",
    buttons = c("copy", "csv", "excel", "pdf", "print")
  )
) %>%
formatSignif(
  columns = round_cols,
  digits = 4
) %>%
formatRound(
  columns = bp_cols,
  digits = 0,
  interval = NULL
)
```

## ENCODE cCRE

```{r ccre}

# Load cCRE annotation
ccre_df <- read.table(
  params$ccre_path,
  header = FALSE,
  sep = "\t",
  col.names = c("chr", "start", "end", "accession_old", "accession", "class")
)
# Make starts 1-based
# Not clear in ENCODE documenattion if cCRE starts are 0-based or 1-based
# but since it is a BED file, we will assume it is 0-based
ccre_df$start <- ccre_df$start + 1

ccre_gr <- makeGRangesFromDataFrame(
  ccre_df,
  ignore.strand = TRUE,
  keep.extra.columns = TRUE,
  seqnames.field = "chr",
  start.field = "start",
  end.field = "end",
)

# Calculate overlaps between DMRs and cCRE annotations
hits_obj <- findOverlaps(dmrs_gr, ccre_gr)

dmrs_overlap <- dmrs_df[queryHits(hits_obj),]
ccre_overlap <- ccre_df[subjectHits(hits_obj),]
overlap_df <- cbind(dmrs_overlap, ccre_overlap)

count_dmr_overlap <- length(unique(queryHits(hits_obj)))
```

```{asis, echo = basename(params$ccre_path) == "GRCh38-cCREs.bed"}
cCRE (candidate cis-regulatory element) annotations were sourced from 
https://screen.encodeproject.org/ all human cCREs (hg38) Registry of cCREs V3
```

```{asis, echo = basename(params$ccre_path) == "mm10-cCREs.bed"}
cCRE (candidate cis-regulatory element) annotations were sourced from 
https://screen.encodeproject.org/ all mouse cCREs (mm10) Registry of cCREs V3
```

**`r count_dmr_overlap` / `r total_sig_dmrs`** 
**(`r round((count_dmr_overlap / total_sig_dmrs) * 100, 2)` %)** of DMRs overlap with cCRE annotations.  
Note: a single DMR may have multiple cCRE annotations.

```{r ccre_table}
# Display in table
round_cols <- c("qvalue", "meth.diff")
bp_cols <- c("start", "end")

datatable(
  overlap_df,
  rownames = FALSE,
  extensions = "Buttons",
  options = list(
    dom = "Bfrtip",
    buttons = c("copy", "csv", "excel", "pdf", "print")
  )
) %>%
formatSignif(
  columns = round_cols,
  digits = 4
) %>%
formatRound(
  columns = bp_cols,
  digits = 0,
  interval = NULL
)
```

## ENCODE Blacklist

```{r blacklist}

# Load ChromHMM annotation
blacklist_gr <- rtracklayer::import(params$blacklist_path)
blacklist_df <- as.data.frame(blacklist_gr)
blacklist_df <- blacklist_df["name"]

# Calculate overlaps between DMRs and blacklist annotations
hits_obj <- findOverlaps(dmrs_gr, blacklist_gr)

dmrs_overlap <- dmrs_df[queryHits(hits_obj),]
blacklist_overlap <- blacklist_df[subjectHits(hits_obj),]
blacklist.state <- blacklist_overlap
overlap_df <- cbind(dmrs_overlap, blacklist.state)

count_dmr_overlap <- length(unique(queryHits(hits_obj)))
```

```{asis, echo = basename(params$blacklist_path) == "hg38-blacklist.v2.bed"}
blacklist annotations were sourced from https://github.com/Boyle-Lab/Blacklist/blob/master/lists/hg38-blacklist.v2.bed.gz
```

```{asis, echo = basename(params$blacklist_path) == "mm10-blacklist.v2.bed"}
ChromHMM annotations were sourced from https://github.com/Boyle-Lab/Blacklist/blob/master/lists/mm10-blacklist.v2.bed.gz
```

**`r count_dmr_overlap` / `r total_sig_dmrs`** 
**(`r round((count_dmr_overlap / total_sig_dmrs) * 100, 2)` %)** of DMRs overlap with blacklist annotations.  
Note: a single DMR may have multiple blacklist annotations.

```{r blacklist_table}
# Display in table
round_cols <- c("qvalue", "meth.diff")
bp_cols <- c("start", "end")

datatable(
  overlap_df,
  rownames = FALSE,
  extensions = "Buttons",
  options = list(
    dom = "Bfrtip",
    buttons = c("copy", "csv", "excel", "pdf", "print")
  )
) %>%
formatSignif(
  columns = round_cols,
  digits = 4
) %>%
formatRound(
  columns = bp_cols,
  digits = 0,
  interval = NULL
)
```
